package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Ayna5/hw-golangOtus/hw12_13_14_15_calendar/pkg/calendar.CalendarClient -o ./mocks/calendar_client_minimock.go

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_calendar_pb "github.com/Ayna5/hw-golangOtus/hw12_13_14_15_calendar/pkg/calendar"
	"github.com/gojuno/minimock/v3"
	grpc "google.golang.org/grpc"
)

// CalendarClientMock implements calendar_pb.CalendarClient
type CalendarClientMock struct {
	t minimock.Tester

	funcCreateEvent          func(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption) (cp1 *mm_calendar_pb.CreateEventResponse, err error)
	inspectFuncCreateEvent   func(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption)
	afterCreateEventCounter  uint64
	beforeCreateEventCounter uint64
	CreateEventMock          mCalendarClientMockCreateEvent

	funcDeleteEvent          func(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption) (dp1 *mm_calendar_pb.DeleteEventResponse, err error)
	inspectFuncDeleteEvent   func(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption)
	afterDeleteEventCounter  uint64
	beforeDeleteEventCounter uint64
	DeleteEventMock          mCalendarClientMockDeleteEvent

	funcGetEvents          func(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption) (gp1 *mm_calendar_pb.GetEventsResponse, err error)
	inspectFuncGetEvents   func(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption)
	afterGetEventsCounter  uint64
	beforeGetEventsCounter uint64
	GetEventsMock          mCalendarClientMockGetEvents

	funcUpdateEvent          func(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption) (up1 *mm_calendar_pb.UpdateEventResponse, err error)
	inspectFuncUpdateEvent   func(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption)
	afterUpdateEventCounter  uint64
	beforeUpdateEventCounter uint64
	UpdateEventMock          mCalendarClientMockUpdateEvent
}

// NewCalendarClientMock returns a mock for calendar_pb.CalendarClient
func NewCalendarClientMock(t minimock.Tester) *CalendarClientMock {
	m := &CalendarClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEventMock = mCalendarClientMockCreateEvent{mock: m}
	m.CreateEventMock.callArgs = []*CalendarClientMockCreateEventParams{}

	m.DeleteEventMock = mCalendarClientMockDeleteEvent{mock: m}
	m.DeleteEventMock.callArgs = []*CalendarClientMockDeleteEventParams{}

	m.GetEventsMock = mCalendarClientMockGetEvents{mock: m}
	m.GetEventsMock.callArgs = []*CalendarClientMockGetEventsParams{}

	m.UpdateEventMock = mCalendarClientMockUpdateEvent{mock: m}
	m.UpdateEventMock.callArgs = []*CalendarClientMockUpdateEventParams{}

	return m
}

type mCalendarClientMockCreateEvent struct {
	mock               *CalendarClientMock
	defaultExpectation *CalendarClientMockCreateEventExpectation
	expectations       []*CalendarClientMockCreateEventExpectation

	callArgs []*CalendarClientMockCreateEventParams
	mutex    sync.RWMutex
}

// CalendarClientMockCreateEventExpectation specifies expectation struct of the CalendarClient.CreateEvent
type CalendarClientMockCreateEventExpectation struct {
	mock    *CalendarClientMock
	params  *CalendarClientMockCreateEventParams
	results *CalendarClientMockCreateEventResults
	Counter uint64
}

// CalendarClientMockCreateEventParams contains parameters of the CalendarClient.CreateEvent
type CalendarClientMockCreateEventParams struct {
	ctx  context.Context
	in   *mm_calendar_pb.CreateEventRequest
	opts []grpc.CallOption
}

// CalendarClientMockCreateEventResults contains results of the CalendarClient.CreateEvent
type CalendarClientMockCreateEventResults struct {
	cp1 *mm_calendar_pb.CreateEventResponse
	err error
}

// Expect sets up expected params for CalendarClient.CreateEvent
func (mmCreateEvent *mCalendarClientMockCreateEvent) Expect(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption) *mCalendarClientMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("CalendarClientMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &CalendarClientMockCreateEventExpectation{}
	}

	mmCreateEvent.defaultExpectation.params = &CalendarClientMockCreateEventParams{ctx, in, opts}
	for _, e := range mmCreateEvent.expectations {
		if minimock.Equal(e.params, mmCreateEvent.defaultExpectation.params) {
			mmCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEvent.defaultExpectation.params)
		}
	}

	return mmCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the CalendarClient.CreateEvent
func (mmCreateEvent *mCalendarClientMockCreateEvent) Inspect(f func(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption)) *mCalendarClientMockCreateEvent {
	if mmCreateEvent.mock.inspectFuncCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("Inspect function is already set for CalendarClientMock.CreateEvent")
	}

	mmCreateEvent.mock.inspectFuncCreateEvent = f

	return mmCreateEvent
}

// Return sets up results that will be returned by CalendarClient.CreateEvent
func (mmCreateEvent *mCalendarClientMockCreateEvent) Return(cp1 *mm_calendar_pb.CreateEventResponse, err error) *CalendarClientMock {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("CalendarClientMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &CalendarClientMockCreateEventExpectation{mock: mmCreateEvent.mock}
	}
	mmCreateEvent.defaultExpectation.results = &CalendarClientMockCreateEventResults{cp1, err}
	return mmCreateEvent.mock
}

//Set uses given function f to mock the CalendarClient.CreateEvent method
func (mmCreateEvent *mCalendarClientMockCreateEvent) Set(f func(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption) (cp1 *mm_calendar_pb.CreateEventResponse, err error)) *CalendarClientMock {
	if mmCreateEvent.defaultExpectation != nil {
		mmCreateEvent.mock.t.Fatalf("Default expectation is already set for the CalendarClient.CreateEvent method")
	}

	if len(mmCreateEvent.expectations) > 0 {
		mmCreateEvent.mock.t.Fatalf("Some expectations are already set for the CalendarClient.CreateEvent method")
	}

	mmCreateEvent.mock.funcCreateEvent = f
	return mmCreateEvent.mock
}

// When sets expectation for the CalendarClient.CreateEvent which will trigger the result defined by the following
// Then helper
func (mmCreateEvent *mCalendarClientMockCreateEvent) When(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption) *CalendarClientMockCreateEventExpectation {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("CalendarClientMock.CreateEvent mock is already set by Set")
	}

	expectation := &CalendarClientMockCreateEventExpectation{
		mock:   mmCreateEvent.mock,
		params: &CalendarClientMockCreateEventParams{ctx, in, opts},
	}
	mmCreateEvent.expectations = append(mmCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up CalendarClient.CreateEvent return parameters for the expectation previously defined by the When method
func (e *CalendarClientMockCreateEventExpectation) Then(cp1 *mm_calendar_pb.CreateEventResponse, err error) *CalendarClientMock {
	e.results = &CalendarClientMockCreateEventResults{cp1, err}
	return e.mock
}

// CreateEvent implements calendar_pb.CalendarClient
func (mmCreateEvent *CalendarClientMock) CreateEvent(ctx context.Context, in *mm_calendar_pb.CreateEventRequest, opts ...grpc.CallOption) (cp1 *mm_calendar_pb.CreateEventResponse, err error) {
	mm_atomic.AddUint64(&mmCreateEvent.beforeCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEvent.afterCreateEventCounter, 1)

	if mmCreateEvent.inspectFuncCreateEvent != nil {
		mmCreateEvent.inspectFuncCreateEvent(ctx, in, opts...)
	}

	mm_params := &CalendarClientMockCreateEventParams{ctx, in, opts}

	// Record call args
	mmCreateEvent.CreateEventMock.mutex.Lock()
	mmCreateEvent.CreateEventMock.callArgs = append(mmCreateEvent.CreateEventMock.callArgs, mm_params)
	mmCreateEvent.CreateEventMock.mutex.Unlock()

	for _, e := range mmCreateEvent.CreateEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateEvent.CreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEvent.CreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEvent.CreateEventMock.defaultExpectation.params
		mm_got := CalendarClientMockCreateEventParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEvent.t.Errorf("CalendarClientMock.CreateEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEvent.CreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEvent.t.Fatal("No results are set for the CalendarClientMock.CreateEvent")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateEvent.funcCreateEvent != nil {
		return mmCreateEvent.funcCreateEvent(ctx, in, opts...)
	}
	mmCreateEvent.t.Fatalf("Unexpected call to CalendarClientMock.CreateEvent. %v %v %v", ctx, in, opts)
	return
}

// CreateEventAfterCounter returns a count of finished CalendarClientMock.CreateEvent invocations
func (mmCreateEvent *CalendarClientMock) CreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.afterCreateEventCounter)
}

// CreateEventBeforeCounter returns a count of CalendarClientMock.CreateEvent invocations
func (mmCreateEvent *CalendarClientMock) CreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.beforeCreateEventCounter)
}

// Calls returns a list of arguments used in each call to CalendarClientMock.CreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEvent *mCalendarClientMockCreateEvent) Calls() []*CalendarClientMockCreateEventParams {
	mmCreateEvent.mutex.RLock()

	argCopy := make([]*CalendarClientMockCreateEventParams, len(mmCreateEvent.callArgs))
	copy(argCopy, mmCreateEvent.callArgs)

	mmCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEventDone returns true if the count of the CreateEvent invocations corresponds
// the number of defined expectations
func (m *CalendarClientMock) MinimockCreateEventDone() bool {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateEventInspect logs each unmet expectation
func (m *CalendarClientMock) MinimockCreateEventInspect() {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CalendarClientMock.CreateEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		if m.CreateEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CalendarClientMock.CreateEvent")
		} else {
			m.t.Errorf("Expected call to CalendarClientMock.CreateEvent with params: %#v", *m.CreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		m.t.Error("Expected call to CalendarClientMock.CreateEvent")
	}
}

type mCalendarClientMockDeleteEvent struct {
	mock               *CalendarClientMock
	defaultExpectation *CalendarClientMockDeleteEventExpectation
	expectations       []*CalendarClientMockDeleteEventExpectation

	callArgs []*CalendarClientMockDeleteEventParams
	mutex    sync.RWMutex
}

// CalendarClientMockDeleteEventExpectation specifies expectation struct of the CalendarClient.DeleteEvent
type CalendarClientMockDeleteEventExpectation struct {
	mock    *CalendarClientMock
	params  *CalendarClientMockDeleteEventParams
	results *CalendarClientMockDeleteEventResults
	Counter uint64
}

// CalendarClientMockDeleteEventParams contains parameters of the CalendarClient.DeleteEvent
type CalendarClientMockDeleteEventParams struct {
	ctx  context.Context
	in   *mm_calendar_pb.DeleteEventRequest
	opts []grpc.CallOption
}

// CalendarClientMockDeleteEventResults contains results of the CalendarClient.DeleteEvent
type CalendarClientMockDeleteEventResults struct {
	dp1 *mm_calendar_pb.DeleteEventResponse
	err error
}

// Expect sets up expected params for CalendarClient.DeleteEvent
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) Expect(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption) *mCalendarClientMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("CalendarClientMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &CalendarClientMockDeleteEventExpectation{}
	}

	mmDeleteEvent.defaultExpectation.params = &CalendarClientMockDeleteEventParams{ctx, in, opts}
	for _, e := range mmDeleteEvent.expectations {
		if minimock.Equal(e.params, mmDeleteEvent.defaultExpectation.params) {
			mmDeleteEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEvent.defaultExpectation.params)
		}
	}

	return mmDeleteEvent
}

// Inspect accepts an inspector function that has same arguments as the CalendarClient.DeleteEvent
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) Inspect(f func(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption)) *mCalendarClientMockDeleteEvent {
	if mmDeleteEvent.mock.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("Inspect function is already set for CalendarClientMock.DeleteEvent")
	}

	mmDeleteEvent.mock.inspectFuncDeleteEvent = f

	return mmDeleteEvent
}

// Return sets up results that will be returned by CalendarClient.DeleteEvent
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) Return(dp1 *mm_calendar_pb.DeleteEventResponse, err error) *CalendarClientMock {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("CalendarClientMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &CalendarClientMockDeleteEventExpectation{mock: mmDeleteEvent.mock}
	}
	mmDeleteEvent.defaultExpectation.results = &CalendarClientMockDeleteEventResults{dp1, err}
	return mmDeleteEvent.mock
}

//Set uses given function f to mock the CalendarClient.DeleteEvent method
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) Set(f func(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption) (dp1 *mm_calendar_pb.DeleteEventResponse, err error)) *CalendarClientMock {
	if mmDeleteEvent.defaultExpectation != nil {
		mmDeleteEvent.mock.t.Fatalf("Default expectation is already set for the CalendarClient.DeleteEvent method")
	}

	if len(mmDeleteEvent.expectations) > 0 {
		mmDeleteEvent.mock.t.Fatalf("Some expectations are already set for the CalendarClient.DeleteEvent method")
	}

	mmDeleteEvent.mock.funcDeleteEvent = f
	return mmDeleteEvent.mock
}

// When sets expectation for the CalendarClient.DeleteEvent which will trigger the result defined by the following
// Then helper
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) When(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption) *CalendarClientMockDeleteEventExpectation {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("CalendarClientMock.DeleteEvent mock is already set by Set")
	}

	expectation := &CalendarClientMockDeleteEventExpectation{
		mock:   mmDeleteEvent.mock,
		params: &CalendarClientMockDeleteEventParams{ctx, in, opts},
	}
	mmDeleteEvent.expectations = append(mmDeleteEvent.expectations, expectation)
	return expectation
}

// Then sets up CalendarClient.DeleteEvent return parameters for the expectation previously defined by the When method
func (e *CalendarClientMockDeleteEventExpectation) Then(dp1 *mm_calendar_pb.DeleteEventResponse, err error) *CalendarClientMock {
	e.results = &CalendarClientMockDeleteEventResults{dp1, err}
	return e.mock
}

// DeleteEvent implements calendar_pb.CalendarClient
func (mmDeleteEvent *CalendarClientMock) DeleteEvent(ctx context.Context, in *mm_calendar_pb.DeleteEventRequest, opts ...grpc.CallOption) (dp1 *mm_calendar_pb.DeleteEventResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteEvent.beforeDeleteEventCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEvent.afterDeleteEventCounter, 1)

	if mmDeleteEvent.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.inspectFuncDeleteEvent(ctx, in, opts...)
	}

	mm_params := &CalendarClientMockDeleteEventParams{ctx, in, opts}

	// Record call args
	mmDeleteEvent.DeleteEventMock.mutex.Lock()
	mmDeleteEvent.DeleteEventMock.callArgs = append(mmDeleteEvent.DeleteEventMock.callArgs, mm_params)
	mmDeleteEvent.DeleteEventMock.mutex.Unlock()

	for _, e := range mmDeleteEvent.DeleteEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteEvent.DeleteEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEvent.DeleteEventMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEvent.DeleteEventMock.defaultExpectation.params
		mm_got := CalendarClientMockDeleteEventParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEvent.t.Errorf("CalendarClientMock.DeleteEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEvent.DeleteEventMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEvent.t.Fatal("No results are set for the CalendarClientMock.DeleteEvent")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteEvent.funcDeleteEvent != nil {
		return mmDeleteEvent.funcDeleteEvent(ctx, in, opts...)
	}
	mmDeleteEvent.t.Fatalf("Unexpected call to CalendarClientMock.DeleteEvent. %v %v %v", ctx, in, opts)
	return
}

// DeleteEventAfterCounter returns a count of finished CalendarClientMock.DeleteEvent invocations
func (mmDeleteEvent *CalendarClientMock) DeleteEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.afterDeleteEventCounter)
}

// DeleteEventBeforeCounter returns a count of CalendarClientMock.DeleteEvent invocations
func (mmDeleteEvent *CalendarClientMock) DeleteEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.beforeDeleteEventCounter)
}

// Calls returns a list of arguments used in each call to CalendarClientMock.DeleteEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEvent *mCalendarClientMockDeleteEvent) Calls() []*CalendarClientMockDeleteEventParams {
	mmDeleteEvent.mutex.RLock()

	argCopy := make([]*CalendarClientMockDeleteEventParams, len(mmDeleteEvent.callArgs))
	copy(argCopy, mmDeleteEvent.callArgs)

	mmDeleteEvent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEventDone returns true if the count of the DeleteEvent invocations corresponds
// the number of defined expectations
func (m *CalendarClientMock) MinimockDeleteEventDone() bool {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteEventInspect logs each unmet expectation
func (m *CalendarClientMock) MinimockDeleteEventInspect() {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CalendarClientMock.DeleteEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		if m.DeleteEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CalendarClientMock.DeleteEvent")
		} else {
			m.t.Errorf("Expected call to CalendarClientMock.DeleteEvent with params: %#v", *m.DeleteEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		m.t.Error("Expected call to CalendarClientMock.DeleteEvent")
	}
}

type mCalendarClientMockGetEvents struct {
	mock               *CalendarClientMock
	defaultExpectation *CalendarClientMockGetEventsExpectation
	expectations       []*CalendarClientMockGetEventsExpectation

	callArgs []*CalendarClientMockGetEventsParams
	mutex    sync.RWMutex
}

// CalendarClientMockGetEventsExpectation specifies expectation struct of the CalendarClient.GetEvents
type CalendarClientMockGetEventsExpectation struct {
	mock    *CalendarClientMock
	params  *CalendarClientMockGetEventsParams
	results *CalendarClientMockGetEventsResults
	Counter uint64
}

// CalendarClientMockGetEventsParams contains parameters of the CalendarClient.GetEvents
type CalendarClientMockGetEventsParams struct {
	ctx  context.Context
	in   *mm_calendar_pb.GetEventsRequest
	opts []grpc.CallOption
}

// CalendarClientMockGetEventsResults contains results of the CalendarClient.GetEvents
type CalendarClientMockGetEventsResults struct {
	gp1 *mm_calendar_pb.GetEventsResponse
	err error
}

// Expect sets up expected params for CalendarClient.GetEvents
func (mmGetEvents *mCalendarClientMockGetEvents) Expect(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption) *mCalendarClientMockGetEvents {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("CalendarClientMock.GetEvents mock is already set by Set")
	}

	if mmGetEvents.defaultExpectation == nil {
		mmGetEvents.defaultExpectation = &CalendarClientMockGetEventsExpectation{}
	}

	mmGetEvents.defaultExpectation.params = &CalendarClientMockGetEventsParams{ctx, in, opts}
	for _, e := range mmGetEvents.expectations {
		if minimock.Equal(e.params, mmGetEvents.defaultExpectation.params) {
			mmGetEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEvents.defaultExpectation.params)
		}
	}

	return mmGetEvents
}

// Inspect accepts an inspector function that has same arguments as the CalendarClient.GetEvents
func (mmGetEvents *mCalendarClientMockGetEvents) Inspect(f func(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption)) *mCalendarClientMockGetEvents {
	if mmGetEvents.mock.inspectFuncGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("Inspect function is already set for CalendarClientMock.GetEvents")
	}

	mmGetEvents.mock.inspectFuncGetEvents = f

	return mmGetEvents
}

// Return sets up results that will be returned by CalendarClient.GetEvents
func (mmGetEvents *mCalendarClientMockGetEvents) Return(gp1 *mm_calendar_pb.GetEventsResponse, err error) *CalendarClientMock {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("CalendarClientMock.GetEvents mock is already set by Set")
	}

	if mmGetEvents.defaultExpectation == nil {
		mmGetEvents.defaultExpectation = &CalendarClientMockGetEventsExpectation{mock: mmGetEvents.mock}
	}
	mmGetEvents.defaultExpectation.results = &CalendarClientMockGetEventsResults{gp1, err}
	return mmGetEvents.mock
}

//Set uses given function f to mock the CalendarClient.GetEvents method
func (mmGetEvents *mCalendarClientMockGetEvents) Set(f func(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption) (gp1 *mm_calendar_pb.GetEventsResponse, err error)) *CalendarClientMock {
	if mmGetEvents.defaultExpectation != nil {
		mmGetEvents.mock.t.Fatalf("Default expectation is already set for the CalendarClient.GetEvents method")
	}

	if len(mmGetEvents.expectations) > 0 {
		mmGetEvents.mock.t.Fatalf("Some expectations are already set for the CalendarClient.GetEvents method")
	}

	mmGetEvents.mock.funcGetEvents = f
	return mmGetEvents.mock
}

// When sets expectation for the CalendarClient.GetEvents which will trigger the result defined by the following
// Then helper
func (mmGetEvents *mCalendarClientMockGetEvents) When(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption) *CalendarClientMockGetEventsExpectation {
	if mmGetEvents.mock.funcGetEvents != nil {
		mmGetEvents.mock.t.Fatalf("CalendarClientMock.GetEvents mock is already set by Set")
	}

	expectation := &CalendarClientMockGetEventsExpectation{
		mock:   mmGetEvents.mock,
		params: &CalendarClientMockGetEventsParams{ctx, in, opts},
	}
	mmGetEvents.expectations = append(mmGetEvents.expectations, expectation)
	return expectation
}

// Then sets up CalendarClient.GetEvents return parameters for the expectation previously defined by the When method
func (e *CalendarClientMockGetEventsExpectation) Then(gp1 *mm_calendar_pb.GetEventsResponse, err error) *CalendarClientMock {
	e.results = &CalendarClientMockGetEventsResults{gp1, err}
	return e.mock
}

// GetEvents implements calendar_pb.CalendarClient
func (mmGetEvents *CalendarClientMock) GetEvents(ctx context.Context, in *mm_calendar_pb.GetEventsRequest, opts ...grpc.CallOption) (gp1 *mm_calendar_pb.GetEventsResponse, err error) {
	mm_atomic.AddUint64(&mmGetEvents.beforeGetEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEvents.afterGetEventsCounter, 1)

	if mmGetEvents.inspectFuncGetEvents != nil {
		mmGetEvents.inspectFuncGetEvents(ctx, in, opts...)
	}

	mm_params := &CalendarClientMockGetEventsParams{ctx, in, opts}

	// Record call args
	mmGetEvents.GetEventsMock.mutex.Lock()
	mmGetEvents.GetEventsMock.callArgs = append(mmGetEvents.GetEventsMock.callArgs, mm_params)
	mmGetEvents.GetEventsMock.mutex.Unlock()

	for _, e := range mmGetEvents.GetEventsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetEvents.GetEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEvents.GetEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEvents.GetEventsMock.defaultExpectation.params
		mm_got := CalendarClientMockGetEventsParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEvents.t.Errorf("CalendarClientMock.GetEvents got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEvents.GetEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEvents.t.Fatal("No results are set for the CalendarClientMock.GetEvents")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetEvents.funcGetEvents != nil {
		return mmGetEvents.funcGetEvents(ctx, in, opts...)
	}
	mmGetEvents.t.Fatalf("Unexpected call to CalendarClientMock.GetEvents. %v %v %v", ctx, in, opts)
	return
}

// GetEventsAfterCounter returns a count of finished CalendarClientMock.GetEvents invocations
func (mmGetEvents *CalendarClientMock) GetEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvents.afterGetEventsCounter)
}

// GetEventsBeforeCounter returns a count of CalendarClientMock.GetEvents invocations
func (mmGetEvents *CalendarClientMock) GetEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEvents.beforeGetEventsCounter)
}

// Calls returns a list of arguments used in each call to CalendarClientMock.GetEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEvents *mCalendarClientMockGetEvents) Calls() []*CalendarClientMockGetEventsParams {
	mmGetEvents.mutex.RLock()

	argCopy := make([]*CalendarClientMockGetEventsParams, len(mmGetEvents.callArgs))
	copy(argCopy, mmGetEvents.callArgs)

	mmGetEvents.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventsDone returns true if the count of the GetEvents invocations corresponds
// the number of defined expectations
func (m *CalendarClientMock) MinimockGetEventsDone() bool {
	for _, e := range m.GetEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvents != nil && mm_atomic.LoadUint64(&m.afterGetEventsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEventsInspect logs each unmet expectation
func (m *CalendarClientMock) MinimockGetEventsInspect() {
	for _, e := range m.GetEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CalendarClientMock.GetEvents with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventsCounter) < 1 {
		if m.GetEventsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CalendarClientMock.GetEvents")
		} else {
			m.t.Errorf("Expected call to CalendarClientMock.GetEvents with params: %#v", *m.GetEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEvents != nil && mm_atomic.LoadUint64(&m.afterGetEventsCounter) < 1 {
		m.t.Error("Expected call to CalendarClientMock.GetEvents")
	}
}

type mCalendarClientMockUpdateEvent struct {
	mock               *CalendarClientMock
	defaultExpectation *CalendarClientMockUpdateEventExpectation
	expectations       []*CalendarClientMockUpdateEventExpectation

	callArgs []*CalendarClientMockUpdateEventParams
	mutex    sync.RWMutex
}

// CalendarClientMockUpdateEventExpectation specifies expectation struct of the CalendarClient.UpdateEvent
type CalendarClientMockUpdateEventExpectation struct {
	mock    *CalendarClientMock
	params  *CalendarClientMockUpdateEventParams
	results *CalendarClientMockUpdateEventResults
	Counter uint64
}

// CalendarClientMockUpdateEventParams contains parameters of the CalendarClient.UpdateEvent
type CalendarClientMockUpdateEventParams struct {
	ctx  context.Context
	in   *mm_calendar_pb.UpdateEventRequest
	opts []grpc.CallOption
}

// CalendarClientMockUpdateEventResults contains results of the CalendarClient.UpdateEvent
type CalendarClientMockUpdateEventResults struct {
	up1 *mm_calendar_pb.UpdateEventResponse
	err error
}

// Expect sets up expected params for CalendarClient.UpdateEvent
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) Expect(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption) *mCalendarClientMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("CalendarClientMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &CalendarClientMockUpdateEventExpectation{}
	}

	mmUpdateEvent.defaultExpectation.params = &CalendarClientMockUpdateEventParams{ctx, in, opts}
	for _, e := range mmUpdateEvent.expectations {
		if minimock.Equal(e.params, mmUpdateEvent.defaultExpectation.params) {
			mmUpdateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEvent.defaultExpectation.params)
		}
	}

	return mmUpdateEvent
}

// Inspect accepts an inspector function that has same arguments as the CalendarClient.UpdateEvent
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) Inspect(f func(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption)) *mCalendarClientMockUpdateEvent {
	if mmUpdateEvent.mock.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("Inspect function is already set for CalendarClientMock.UpdateEvent")
	}

	mmUpdateEvent.mock.inspectFuncUpdateEvent = f

	return mmUpdateEvent
}

// Return sets up results that will be returned by CalendarClient.UpdateEvent
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) Return(up1 *mm_calendar_pb.UpdateEventResponse, err error) *CalendarClientMock {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("CalendarClientMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &CalendarClientMockUpdateEventExpectation{mock: mmUpdateEvent.mock}
	}
	mmUpdateEvent.defaultExpectation.results = &CalendarClientMockUpdateEventResults{up1, err}
	return mmUpdateEvent.mock
}

//Set uses given function f to mock the CalendarClient.UpdateEvent method
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) Set(f func(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption) (up1 *mm_calendar_pb.UpdateEventResponse, err error)) *CalendarClientMock {
	if mmUpdateEvent.defaultExpectation != nil {
		mmUpdateEvent.mock.t.Fatalf("Default expectation is already set for the CalendarClient.UpdateEvent method")
	}

	if len(mmUpdateEvent.expectations) > 0 {
		mmUpdateEvent.mock.t.Fatalf("Some expectations are already set for the CalendarClient.UpdateEvent method")
	}

	mmUpdateEvent.mock.funcUpdateEvent = f
	return mmUpdateEvent.mock
}

// When sets expectation for the CalendarClient.UpdateEvent which will trigger the result defined by the following
// Then helper
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) When(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption) *CalendarClientMockUpdateEventExpectation {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("CalendarClientMock.UpdateEvent mock is already set by Set")
	}

	expectation := &CalendarClientMockUpdateEventExpectation{
		mock:   mmUpdateEvent.mock,
		params: &CalendarClientMockUpdateEventParams{ctx, in, opts},
	}
	mmUpdateEvent.expectations = append(mmUpdateEvent.expectations, expectation)
	return expectation
}

// Then sets up CalendarClient.UpdateEvent return parameters for the expectation previously defined by the When method
func (e *CalendarClientMockUpdateEventExpectation) Then(up1 *mm_calendar_pb.UpdateEventResponse, err error) *CalendarClientMock {
	e.results = &CalendarClientMockUpdateEventResults{up1, err}
	return e.mock
}

// UpdateEvent implements calendar_pb.CalendarClient
func (mmUpdateEvent *CalendarClientMock) UpdateEvent(ctx context.Context, in *mm_calendar_pb.UpdateEventRequest, opts ...grpc.CallOption) (up1 *mm_calendar_pb.UpdateEventResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateEvent.beforeUpdateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEvent.afterUpdateEventCounter, 1)

	if mmUpdateEvent.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.inspectFuncUpdateEvent(ctx, in, opts...)
	}

	mm_params := &CalendarClientMockUpdateEventParams{ctx, in, opts}

	// Record call args
	mmUpdateEvent.UpdateEventMock.mutex.Lock()
	mmUpdateEvent.UpdateEventMock.callArgs = append(mmUpdateEvent.UpdateEventMock.callArgs, mm_params)
	mmUpdateEvent.UpdateEventMock.mutex.Unlock()

	for _, e := range mmUpdateEvent.UpdateEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateEvent.UpdateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEvent.UpdateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEvent.UpdateEventMock.defaultExpectation.params
		mm_got := CalendarClientMockUpdateEventParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEvent.t.Errorf("CalendarClientMock.UpdateEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEvent.UpdateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEvent.t.Fatal("No results are set for the CalendarClientMock.UpdateEvent")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateEvent.funcUpdateEvent != nil {
		return mmUpdateEvent.funcUpdateEvent(ctx, in, opts...)
	}
	mmUpdateEvent.t.Fatalf("Unexpected call to CalendarClientMock.UpdateEvent. %v %v %v", ctx, in, opts)
	return
}

// UpdateEventAfterCounter returns a count of finished CalendarClientMock.UpdateEvent invocations
func (mmUpdateEvent *CalendarClientMock) UpdateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.afterUpdateEventCounter)
}

// UpdateEventBeforeCounter returns a count of CalendarClientMock.UpdateEvent invocations
func (mmUpdateEvent *CalendarClientMock) UpdateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.beforeUpdateEventCounter)
}

// Calls returns a list of arguments used in each call to CalendarClientMock.UpdateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEvent *mCalendarClientMockUpdateEvent) Calls() []*CalendarClientMockUpdateEventParams {
	mmUpdateEvent.mutex.RLock()

	argCopy := make([]*CalendarClientMockUpdateEventParams, len(mmUpdateEvent.callArgs))
	copy(argCopy, mmUpdateEvent.callArgs)

	mmUpdateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEventDone returns true if the count of the UpdateEvent invocations corresponds
// the number of defined expectations
func (m *CalendarClientMock) MinimockUpdateEventDone() bool {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateEventInspect logs each unmet expectation
func (m *CalendarClientMock) MinimockUpdateEventInspect() {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CalendarClientMock.UpdateEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		if m.UpdateEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CalendarClientMock.UpdateEvent")
		} else {
			m.t.Errorf("Expected call to CalendarClientMock.UpdateEvent with params: %#v", *m.UpdateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		m.t.Error("Expected call to CalendarClientMock.UpdateEvent")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CalendarClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateEventInspect()

		m.MinimockDeleteEventInspect()

		m.MinimockGetEventsInspect()

		m.MinimockUpdateEventInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CalendarClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CalendarClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEventDone() &&
		m.MinimockDeleteEventDone() &&
		m.MinimockGetEventsDone() &&
		m.MinimockUpdateEventDone()
}
